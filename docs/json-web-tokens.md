---
sidebar_position: 2
title: JWT(JSON Web Token)介紹
---

## 什麼是 JSON Web Token?

JSON Web Token (JWT) 是一個公認的開放標準 [RFC 7519](https://datatracker.ietf.org/doc/html/rfc7519)，它以一種簡潔且自足的方式定義了如何安全地在各方之間傳遞資訊，這些資訊以 JSON 格式表達。由於這些資訊經過數位簽名，因此可以進行驗證並被信任。JWTs 可以透過 HMAC 算法和密鑰進行簽名，或者使用 RSA 或 ECDSA 的公私鑰技術簽名。

儘管 JWTs 也可以進行加密，以保護資訊間的隱私，但我們這裡主要討論的是簽名機制。透過簽名的 JWTs 能夠確認其中包含的聲明是完整無誤的，而加密的 JWTs 則能對其他方隱藏這些聲明。當 JWTs 使用公私鑰對進行簽名時，該簽名還證明了只有持有私鑰的人才是真正的簽名者。

## 你在何時需要使用 JWT?

* 授權(Authorization)：JWT 最常用於授權場景。用戶一旦登入，他們的每一次請求都會攜帶 JWT，這使得用戶能夠訪問他們用該 Token 獲得權限的路徑、服務及資源。現今，單一登入功能廣泛採用了 JWT，原因在於它的輕量性和易於跨不同領域使用的特點。

* 資訊交換：JTWs 是一種在各方之間安全交換資訊的有效方式。由於 JWT 可以進行簽名，比如使用公私鑰對，因此你可以確定發送者的身份無誤。此外，由於簽名是基於標頭和有效內容計算的，這也意味著你能夠確認傳輸的內容沒有被篡改。

## JWT 的結構

在 JSON Web Tokens 的緊湊格式中，它由三個用點（.）分隔的部分組成，這些部分分別是：

* 標頭（Header）  
* 負載（Payload）  
* 簽章（Signature）  

因此，一個典型的 JWT 的格式會是這樣的：

xxxxx.yyyyy.zzzzz

下面我們來逐一解析這些部分。

### 標頭 Header

標頭部分一般由兩個元素組成：一是 Token 的類型，即「JWT」，二是所採用的簽名算法，例如 HMAC SHA256 或 RSA。

舉個例子：

```json
{
    "alg": "HS256",
    "typ": "JWT"
}
```

然後，這段 JSON 會經過 Base64Url 編碼，從而形成 JWT 的第一部分。

### 負載 Payload

Token 的第二部分是負載，它包含了多個聲明。聲明是對實體（通常指用戶）及額外資料的陳述。聲明分為三類：***註冊聲明***、***公開聲明*** 和 ***私有聲明***。

* 註冊聲明(Registered claims)：這些是一組事先定義好的聲明，雖非強制性的，但建議使用，以便提供一套實用且能夠互相操作的聲明。例如：iss（發行者）、exp（過期時間）、sub（主體）、aud（受眾）等。

:::note
請注意，為了保持 JWT 的緊湊性，這些聲明名稱通常只有三個字母長。
:::

* 公開聲明(Public claims)：JWT 的使用者可以自行定義這些聲明。為了避免名稱衝突，這些聲明應在 [IANA JSON Web Token Registry](https://www.iana.org/assignments/jwt/jwt.xhtml) 中註冊，或者定義為一個包含防碰撞性命名空間的 URI。

* 私有聲明(Private claims)：這些是用於在同意使用這些聲明的各方之間交換資訊的自訂聲明，它們既不屬於註冊聲明也不屬於公開聲明。

一個負載的例子如下：

```json
{
    "sub": "1234567890",
    "name": "John Doe",
    "admin": true
}
```

隨後，這段負載會經過 Base64Url 編碼，形成 JSON Web Token 的第二部分。

:::note
要注意的是，對於簽名的 Token 來說，儘管這些資訊受到篡改保護，但任何人都可以閱讀。除非進行加密，否則不要在 JWT 的標頭或有效載荷部分放置機密資訊。
:::

### 簽章 Signature

要製作簽名部分，你需要取得已編碼的標頭和負載、一個秘密鑰匙，以及標頭中指定的算法，並基於這些進行簽名。

比如說，如果你選擇使用 HMAC SHA256 算法，簽名將按照以下方式生成：

```
HMACSHA256(
  base64UrlEncode(header) + "." +
  base64UrlEncode(payload),
  secret)
```

簽名的作用是確保信息在傳輸過程中未被篡改，並且在使用私鑰進行簽名的 Token 中，還能驗證 JWT 發送者的真實身份。

### 綜合這些元素

生成的結果是三段用點分隔的 Base64-URL 字串，這種格式便於在 HTML 和 HTTP 環境中傳遞，且相比基於 XML 的標準（如 SAML）更為緊湊。

以下是一個例子，展示了一個包含上述標頭和有效負載編碼，並用秘密簽名的 JWT。這是編碼後的 JWT。

![jwt-001](./img/jwt-001.png)

如果你想親自實驗 JWT 並將這些概念應用於實踐，可以使用 [jwt.io Debugger](https://jwt.io/#debugger-io) 來解碼、驗證和生成 JWT。

![jwt-002](./img/jwt-002.png)

## JSON Web Tokens 的運作方式是什麼？

在使用者透過帳號密碼成功登入後，系統會回傳一個 JSON Web Token 作為身份驗證的憑據。由於這些令牌涉及安全性，因此必須嚴格管理，避免任何安全隱患。通常情況下，不建議將令牌保存時間過長。

此外，考慮到安全性問題，敏感的會話資料不應儲存在瀏覽器存儲中。

當用戶需要進入受保護的路徑或資源時，應透過用戶端代理發送 JWT，通常這是透過在 Authorization header 中附加 Bearer 格式來完成。其格式如下：

```
Authorization: Bearer <token>
```

在特定情況下，這種方法可實現無狀態授權。當伺服器偵測到 Authorization header 中有有效的 JWT 時，將允許用戶訪問受保護的資源。倘若 JWT 中已包含所需資料，則有可能減少對資料庫的查詢需求，但這不是絕對的。

要注意的是，透過 HTTP header 傳送 JWT 時，最好避免令牌過大。有些伺服器對頭部資料的接受限制為 8 KB。如果令牌中包含過多資訊，例如包含用戶所有權限資料，則可能需要尋找其他解決方案，例如使用 Auth0 的細粒度授權。

若 JWT 是透過 Authorization header 發送，則不會引起跨來源資源共享（CORS）的問題，因為它不依賴 cookies。

以下示意圖展示了如何獲取並利用 JWT 存取 API 或其他資源：

![jwt-003](./img/jwt-003.png)

1. 客戶端或應用程式需要向授權伺服器申請授權，這通常是透過數種不同的授權流程來完成的。舉例來說，一個遵循 OpenID Connect 標準的典型網路應用程式會透過 /oauth/authorize 這個端點，採用授權碼流程進行授權。
2. 一旦授權成功，授權伺服器會回傳一個存取令牌給應用程式。
3. 接著，應用程式利用這個存取令牌來訪問受保護的資源，例如 API。

要特別留意的是，對於已經簽名的令牌，其內含的所有信息都是對使用者或其他相關方公開的，儘管他們無法修改這些信息。因此，切勿在令牌中儲存任何機密資料。

如何運作 JSON Web Token

客戶端或應用程序向授權伺服器請求授權，這通常透過不同的授權流程來實現。比如，一個遵循 OpenID Connect 的 Web 應用會透過 /oauth/authorize 端點，使用授權代碼流程來進行。
授權成功後，授權伺服器會將存取令牌發送給應用程序。
應用程序則利用這個存取令牌來存取受保護的資源，如 API。
值得注意的是，即使使用了簽名的令牌，令牌內的所有資訊對於使用者或第三方都是可見的，雖然他們無法更改這些資訊。因此，不應該在令牌中存放任何秘密資訊。

## 為何我們應該用 JSON Web Tokens?

為什麼選擇 JSON Web Tokens (JWT) 呢？讓我們來探討一下，與 Simple Web Tokens (SWT) 和 Security Assertion Markup Language Tokens (SAML) 相比，JWT 的優勢所在。

首先，JSON 的結構比 XML 更為精簡，所以當它被編碼後，其大小也相對較小，這使得 JWT 在 HTML 和 HTTP 環境下傳輸時更為高效。

從安全角度來看，SWT 只能透過 HMAC 算法使用共享秘鑰進行對稱加密。相比之下，JWT 和 SAML 則可以採用公/私鑰對，並使用 X.509 證書進行簽名。相較於 JSON，要在 XML 上實現數位簽名且不引入安全隱患相對困難得多。

此外，多數程式語言都支援 JSON 解析，因為它們可以直接與對象進行映射。而 XML 則缺乏直觀的文檔對象映射，這使得 JWT 的處理比 SAML 斷言來得簡便。

在實際應用方面，JWT 已經被廣泛應用於互聯網規模的場景，尤其在多平台客戶端處理上，特別是在移動設備上，展現了其便利性。

參考：[Introduction to JSON Web Tokens](https://jwt.io/introduction)